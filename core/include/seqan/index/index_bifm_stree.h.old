// ==========================================================================
//                 SeqAn - The Library for Sequence Analysis
// ==========================================================================
// Copyright (c) 2006-2013, Knut Reinert, FU Berlin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Knut Reinert or the FU Berlin nor the names of
//       its contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.
//
// ==========================================================================
// Author: Christopher Pockrandt <christopher.pockrandt@fu-berlin.de>
// ==========================================================================

//SEQAN_NO_DDDOC:do not generate documentation for this file

#ifndef INDEX_BIFM_STREE_H_
#define INDEX_BIFM_STREE_H_

namespace seqan {

// TODO:christopher: try to remove this struct and introduce subclassing in FMIndex instead
struct BiDirectional;

// ==========================================================================
// Classes
// ==========================================================================

// ----------------------------------------------------------------------------
// Class BidirectionalFMIndex-Iter
// ----------------------------------------------------------------------------

template < typename TText, class TSpec3, class TOccSpec, class TSpec >
class Iter< Index<TText, BidirectionalFMIndex<TOccSpec, TSpec3> >, VSTree< TopDown<TSpec> > >
{
public:
	typedef ModifiedString<TText, ModReverse>								TRevText;

	typedef Index<TText, BidirectionalFMIndex<TOccSpec, TSpec3> >			TBiIndex;

	typedef Index<TText, FMIndex<TOccSpec, TSpec3> >						TIndex;
	typedef Index<TRevText, FMIndex<TOccSpec, TSpec3> >						TRevIndex;

	typedef Iter<TIndex, VSTree<TopDown<BiDirectional> > >	TIndexIter;
	typedef Iter<TRevIndex, VSTree<TopDown<BiDirectional> > >	TRevIndexIter;

	TIndexIter		fwdIter;
	TRevIndexIter	bwdIter;

//____________________________________________________________________________

	// TODO:christopher: adjust all the other constructors
	// TODO:christopher: what about parent links, about the history, etc. Those methods will probably need slight modifications
	Iter() {
	}

	Iter(TBiIndex &_index):
		fwdIter(*(&_index.fwd)),
		bwdIter(*(&_index.rev))
	{
		fwdIter.setRevIter(bwdIter);
		bwdIter.setRevIter(fwdIter);
	}

	/*Iter(TBiIndex &_index, MinimalCtor):
		rev_index(&_index.rev),
		index(&_index.fwd),
		vDesc(MinimalCtor()),
		_parentDesc(MinimalCtor()) {}

	// NOTE(esiragusa): _parentDesc is unitialized
	Iter(TBiIndex &_index, TVertexDesc const &_vDesc):
		rev_index(&_index.rev),
		index(&_index.fwd),
		vDesc(_vDesc)
	{
		_indexRequireTopDownIteration(_index.rev);
		_indexRequireTopDownIteration(_index.fwd);
	}

	template <typename TSpec2>
	Iter(Iter<TBiIndex, VSTree<TopDown<TSpec2> > > const &_origin):
		rev_index(&container(_origin.rev)),
		index(&container(_origin.fwd)),
		vDesc(value(_origin)),
		_parentDesc(nodeUp(_origin)) {}

//____________________________________________________________________________

	template <typename TSpec2>
	inline Iter const &
	operator = (Iter<TBiIndex, VSTree<TopDown<TSpec2> > > const &_origin)
	{
		rev_index = &container(_origin).rev;
		index = &container(_origin).fwd;
		vDesc = value(_origin);
		_parentDesc = nodeUp(_origin);
		return *this;
	}*/
};





/*template < typename TVSTreeIter >
struct HistoryStackEntry_;

template <typename TSize>
struct HistoryStackEsa_
{
	Pair<TSize> range;		// current SA interval of hits
	HistoryStackEsa_() {}
	template <typename TSize_>
	HistoryStackEsa_(Pair<TSize_> const &_range): range(_range) {}
};

template < typename TIndex, typename TSpec >
struct HistoryStackEntry_< Iter< TIndex, VSTree< TopDown< ParentLinks<TSpec> > > > >
{
	typedef HistoryStackEsa_<typename Size<TIndex>::Type>	Type;
};*/




template < typename TText, class TOccSpec, class TSpec3 >
class Iter< Index<ModifiedString<TText, ModReverse>, FMIndex<TOccSpec, TSpec3> >, VSTree<TopDown<BiDirectional> > >
{
public:

	typedef ModifiedString<TText, ModReverse>				TRevText;
	typedef Index<TText, FMIndex<TOccSpec, TSpec3> >		TRevIndex;
	typedef Index<TRevText, FMIndex<TOccSpec, TSpec3> >		TIndex;

	typedef typename VertexDescriptor<TIndex>::Type			TVertexDesc;

	typedef Iter																iterator;
	typedef Iter<TIndex, VSTree< TopDown<BiDirectional> > >		TIndexIter;
	typedef Iter<TRevIndex, VSTree< TopDown<BiDirectional> > >	TRevIndexIter;

	typedef	typename HistoryStackEntry_<Iter>::Type	TStackEntry;
	typedef String<TStackEntry, Block<> >			TStack;

	TIndex const		*index;		// container of all necessary tables
	TRevIndexIter /*const*/	*revIter;	// container of all necessary tables
	TVertexDesc			vDesc;		// current interval in suffix array and
									// right border of parent interval (needed in goRight)

	// pseudo history stack (to go up at most one node)
	TVertexDesc		_parentDesc;

	TStack			history;	// contains all previously visited intervals (allows to go up)

//____________________________________________________________________________

	Iter() : index() {
	}

	Iter(TIndex &_index):
		index(&_index)
	{
		_indexRequireTopDownIteration(_index);
		goRoot(*this);
	}

	Iter(TIndex &_index, MinimalCtor):
		index(&_index),
		vDesc(MinimalCtor()),
		_parentDesc(MinimalCtor()) {}

	// NOTE(esiragusa): _parentDesc is unitialized
	Iter(TIndex &_index, TVertexDesc const &_vDesc):
		index(&_index),
		vDesc(_vDesc)
	{
		_indexRequireTopDownIteration(_index);
	}

	template <typename TSpec2>
	Iter(Iter<TIndex, VSTree<TopDown<TSpec2> > > const &_origin):
		index(&container(_origin)),
		vDesc(value(_origin)),
		_parentDesc(nodeUp(_origin)),
		history(_origin.histor) {}

//____________________________________________________________________________

	template <typename TSpec2>
	inline Iter const &
	operator = (Iter<TIndex, VSTree<TopDown<TSpec2> > > const &_origin)
	{
		index = &container(_origin);
		vDesc = value(_origin);
		_parentDesc = nodeUp(_origin);
		history = _origin.history;
		return *this;
	}

	void setRevIter(TRevIndexIter /*const*/ &_revIter)
	{
		revIter = &_revIter;
	}
};

template < typename TText, class TOccSpec, class TSpec3 >
class Iter< Index<TText, FMIndex<TOccSpec, TSpec3> >, VSTree< TopDown<BiDirectional> > >
{
public:

	typedef Index<TText, FMIndex<TOccSpec, TSpec3> >					TIndex;
	typedef typename VertexDescriptor<TIndex>::Type						TVertexDesc;

	typedef Iter														iterator;
	typedef ModifiedString<TText, ModReverse>							TRevText;
	typedef Index<TRevText, FMIndex<TOccSpec, TSpec3> >					TRevIndex;
	typedef Iter<TIndex, VSTree< TopDown<BiDirectional> > >				TIndexIter;
	typedef Iter<TRevIndex, VSTree< TopDown<BiDirectional> > >			TRevIndexIter;

	typedef	typename HistoryStackEntry_<Iter>::Type	TStackEntry;
	typedef String<TStackEntry, Block<> >			TStack;

	TIndex const		*index;		// container of all necessary tables
	TRevIndexIter /*const*/	*revIter;	// container of all necessary tables
	TVertexDesc			vDesc;		// current interval in suffix array and
									// right border of parent interval (needed in goRight)

	// pseudo history stack (to go up at most one node)
	TVertexDesc		_parentDesc;

	TStack			history;	// contains all previously visited intervals (allows to go up)

//____________________________________________________________________________

	Iter() : index() {
	}

	Iter(TIndex &_index):
		index(&_index)
	{
		_indexRequireTopDownIteration(_index);
		goRoot(*this);
	}

	Iter(TIndex &_index, MinimalCtor):
		index(&_index),
		vDesc(MinimalCtor()),
		_parentDesc(MinimalCtor()) {}

	// NOTE(esiragusa): _parentDesc is unitialized
	Iter(TIndex &_index, TVertexDesc const &_vDesc):
		index(&_index),
		vDesc(_vDesc)
	{
		_indexRequireTopDownIteration(_index);
	}

	template <typename TSpec2>
	Iter(Iter<TIndex, VSTree<TopDown<TSpec2> > > const &_origin):
		index(&container(_origin)),
		vDesc(value(_origin)),
		_parentDesc(nodeUp(_origin)),
		history(_origin.history) {}

//____________________________________________________________________________

	template <typename TSpec2>
	inline Iter const &
	operator = (Iter<TIndex, VSTree<TopDown<TSpec2> > > const &_origin)
	{
		index = &container(_origin);
		vDesc = value(_origin);
		_parentDesc = nodeUp(_origin);
		history = _origin.history;
		return *this;
	}

	void setRevIter(TRevIndexIter /*const*/ &_revIter)
	{
		revIter = &_revIter;
	}
};

// ============================================================================
// Functions
// ============================================================================

// ----------------------------------------------------------------------------
// Function _getNodeByChar()                                         [Iterator]
// ----------------------------------------------------------------------------

// TODO:christopher: simplify, documentation, commands
template <typename TText, typename TOccSpec, typename TIndexSpec, typename TChar>
inline bool _getNodeByChar(Iter<Index<TText, FMIndex<TOccSpec, TIndexSpec> >, VSTree<TopDown<BiDirectional> > > const & it,
                           typename VertexDescriptor<Index<TText, FMIndex<TOccSpec, TIndexSpec> > >::Type const & vDesc,
                           Pair<typename Size<Index<TText, FMIndex<TOccSpec, TIndexSpec> > >::Type> & _range,
                           TChar c)
{
    typedef Index<TText, FMIndex<TOccSpec, TIndexSpec> >        TIndex;
    typedef typename Value<TIndex>::Type                        TAlphabet;
    typedef typename ValueSize<TAlphabet>::Type                 TAlphabetSize;
    typedef typename Size<TIndex>::Type                         TSize;

    typedef typename Fibre<TIndex, FibreLfTable>::Type          TLfTable;
    typedef typename Fibre<TLfTable, FibrePrefixSumTable>::Type TPrefixSumTable;

    TIndex const & _index = container(it);
    TPrefixSumTable const & pst = getFibre(getFibre(_index, FibreLfTable()), FibrePrefixSumTable());

    TAlphabetSize cPosition = getCharacterPosition(pst, c);

	typedef typename Value<typename Fibre<PrefixSumTable<TChar>, FibreEntries>::Type>::Type TPrefixSumValue2;

	unsigned alpSize = length(pst);

	unsigned int sum = 0;
	for (TPrefixSumValue2 i = 0; i < std::min(alpSize, (unsigned int) c); ++i)
	{
		unsigned int i1, i2;
		TChar d = TAlphabet(i);

		if (_isRoot(vDesc))
		{
			unsigned int dPosition = getCharacterPosition(pst, d);
			i1 = getPrefixSum(pst, dPosition);
			i2 = getPrefixSum(pst, dPosition + 1);
		}
		else
		{
			i1 = countOccurrences(_index.lfTable.occTable, d, vDesc.range.i1 - 1);
			i2 = countOccurrences(_index.lfTable.occTable, d, vDesc.range.i2 - 1);
		}

		if (i1 + 1 <= i2)
		{
			sum += i2 - i1;
		}
	}

	unsigned int sentinelPos = _index.lfTable.occTable.sentinelPosition;
	if (vDesc.range.i1 <= sentinelPos && sentinelPos < vDesc.range.i2)
		++sum;

	bool isRoot = _isRoot(vDesc);
    if (isRoot)
    {
        _range.i1 = getPrefixSum(pst, cPosition);
        _range.i2 = getPrefixSum(pst, cPosition + 1);
    }
    else
    {
        TSize prefixSum = getPrefixSum(pst, cPosition);
        _range.i1 = prefixSum + countOccurrences(_index.lfTable.occTable, c, vDesc.range.i1 - 1);
        _range.i2 = prefixSum + countOccurrences(_index.lfTable.occTable, c, vDesc.range.i2 - 1);
    }

    if (_range.i1 + 1 <= _range.i2)
    {
    	// historyPush nicht änderbar, wg. index_fm_stree.h Z. 300 ff. und eigener _getNodeByChar-Impl.! Gibt sonst Probleme mit der Reihenfolge
        _historyPush(*it.revIter); // "it" itself is already pushed in the wrapping method

		if (isRoot)
		{
			value(*it.revIter).range.i1 = _range.i1;
			value(*it.revIter).range.i2 = _range.i2;
		}
		else
		{
			value(*it.revIter).range.i1 += sum;
			value(*it.revIter).range.i2 = value(*it.revIter).range.i1 + (_range.i2 - _range.i1);
		}
		value(*it.revIter).lastChar = c;
		value(*it.revIter).repLen++;
        return true;
    }

    return false;
}

// ----------------------------------------------------------------------------
// Function leftExtend()                                         [Iterator]
// ----------------------------------------------------------------------------
// TODO:christopher: generalize for sequence objects, documentation
template <typename TText, class TIndexSpec, class TOccSpec, typename TChar>
inline
bool leftExtend(Iter<Index<TText, BidirectionalFMIndex<TIndexSpec, TOccSpec> >, VSTree<TopDown<BiDirectional> > > & it, TChar c)
{
	return goDown(it.fwdIter, c);
}

// ----------------------------------------------------------------------------
// Function rightExtend()                                         [Iterator]
// ----------------------------------------------------------------------------
// TODO:christopher: generalize for sequence objects, documentation
template <typename TText, class TIndexSpec, class TOccSpec, typename TChar>
inline
bool rightExtend(Iter<Index<TText, BidirectionalFMIndex<TIndexSpec, TOccSpec> >, VSTree<TopDown<BiDirectional> > > & it, TChar c)
{
	return goDown(it.bwdIter, c);
}












/**************************************************************************
 * HISTORY STUFF *
 */





	// TODO: pointer, etc. checken
	/*template < typename TText, class TOccSpec, class TIndexSpec >
	inline void
	_historyClear(Iter<Index<TText, FMIndex<TOccSpec, TIndexSpec> >, VSTree< TopDown<BiDirectional> > > &it)
	{
		it._parentDesc = value(it);
		// when first iterator is initialized, this method is called but revIter is not initialized yet!
		//(*it.revIter)._parentDesc = value(*it.revIter);
	}

	template < typename TText, class TOccSpec, class TIndexSpec >
	inline void
	_historyClear(Iter<Index<TText, FMIndex<TOccSpec, TIndexSpec> >, VSTree< TopDown< ParentLinks<BiDirectional> > > > &it)
	{
		clear(it.history);
		//clear((*it.revIter).history);
	}*/



	/*template <typename TText, typename TOccSpec, typename TIndexSpec>
	inline void _historyPush(Iter<Index<TText, FMIndex<TOccSpec, TIndexSpec > >, VSTree<TopDown<BiDirectional> > > & it)
	{
	    it._parentDesc = value(it);
	    //(*it.revIter)._parentDesc = value(*it.revIter);
	}*/

	/*template < typename TText, typename TOccSpec, typename TIndexSpec>
	inline void
	_historyPush(Iter<Index<TText, FMIndex<TOccSpec, TIndexSpec > >, VSTree<TopDown<ParentLinks<BiDirectional> > > > & it)
	{
	    typedef Iter<Index<TText, FMIndex<TOccSpec, TIndexSpec > >, VSTree<TopDown<ParentLinks<BiDirectional> > > > TIter;

	    typename HistoryStackEntry_<TIter>::Type h;
	    //typename HistoryStackEntry_<TIter>::Type h2;

	    h.range = value(it).range;
	    h.lastChar = value(it).lastChar;
	    //h2.range = value(*it.revIter).range;
	    //h2.lastChar = value(*it.revIter).lastChar;

	    appendValue(it.history, h);
	    //appendValue((*it.revIter).history, h2);
	}*/




	template <typename TText, typename TOccSpec, typename TIndexSpec>
	bool _goUp(Iter<Index<TText, FMIndex<TOccSpec, TIndexSpec> >, VSTree<TopDown<ParentLinks<BiDirectional> > > > & it)
	{
		if (!isRoot(it))
		{
	        value(it).range = back(it.history).range;
	        value(it).lastChar = back(it.history).lastChar;
	        --value(it).repLen;
	        pop(it.history);

	        value(*it.revIter).range = back((*it.revIter).history).range;
	        value(*it.revIter).lastChar = back((*it.revIter).history).lastChar;
	        --value(*it.revIter).repLen;
	        pop((*it.revIter).history);
	        return true;
	    }

	    return false;
	}

}

#endif /* INDEX_BIFM_STREE_H_ */
